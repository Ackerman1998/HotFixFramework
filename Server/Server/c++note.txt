======================单冒号===========================
单冒号的几种用法：
1.表示继承
class A{}
class B:A{}
2.指定变量占多少bit空间
char a:4;
3.用于构造函数之后，用于初始化一些变量
class Message {
public:
	Message(int num) :msg1(num) {};
	int GetMsg() {
		return msg1;
	}
private:
	int msg1;
};
int main(){
	Message m1{222};
	cout<< m1.GetMsg()<<endl;
}
4.用于public,private等修饰符
public:
	int number;
======================双冒号===========================
双冒号的用法 
1.在类中没有一个方法的定义，在类外定义这个方法，需要使用 类名::方法名对方法定义
2.通过类名直接获取变量，方法，类名::变量名
======================重载运算符===========================
operator 重载运算符
class Message {
public:
	Message(int num) :msg1(num) {};
	bool operator==(const Message mm) {
		if (this->msg1==mm.msg1) {
			return true;
		}
		else {
			return false;
		}
	}
	 static inline std::string adress="ddd";
private:
	int msg1;
};
int main() {
	Message m2{33};
	Message m3{33};
	if (m2==m3) {
		cout << "m2=m3" << endl;
	}
	else {
		cout << "m2!=m3" << endl;
	}
}
result-> m2=m3
=======================c++两种动态内存分配==========================
c++两种动态内存分配方法：
1.new,delete
type* instance =NULL;
instance=new tpye;
delete instance;//释放
2.malloc,free
int* p;
p = (int*)malloc(sizeof(int));
*p = 111;
cout << "Malloc:" << *p << endl;
1和2两者的区别：
1.new使用时无需指定内存块大小，malloc需要手动分配
2.new的返回值就是对象类型的指针，malloc的返回值是void *(表示不
确定的指针类型)，要强制转换成对应的类型
3.new,delete可以使用operator重载
4.new的作用：分配内存和调用构造函数,delete作用：释放内存和调用析构函数
malloc只分配内存，free只释放内存
======================c++星号,&的含义===========================
c++星号的含义：
1.用作乘法的运算
2.定义指针（指针前再加一个星号表示这个指针所指向的值）
int* number=0;
*number=100;
cout << "number:" << *number << endl;
result->:100
3.函数名前的星号：代表返回值是地址类型
c++ &的含义：
表示取地址.
void Swap(int &a,int &b) 和void Swap(int a,int b)的区别
第一种方式:在Swap方法中修改a或b的值，同时外部传入的参数也被修改了,类似于CSharp中的out
用引用(&)传递参数的时间更少
*****************************c++模板****************************************
c++模板：是用来实现代码重用的一种方式，可以实现类型参数化，将类型定义为参数，从而实现了
代码的重用
模板分类为函数模板，类模板
======================c++模板方法===========================
c++模板方法的使用：
template <typename T>
void Swap(T &a,T &b){
	T temp = a;
	a = b;
	b = temp;
}
======================c++类模板===========================
template <class T1,class T2>
class Map {
public:
	T1 key;
	T2 Value;
	Map(T1 k, T2 v) :key(k), Value(v) {};
};
Map m1{"name","joelee"};
cout << m1.key << "\t" << m1.Value << endl;
reuslt->: name  joelee
*****************************c++模板****************************************
======================c++预处理器===========================
预处理器是一些指令，指令c++编译器在编译前完成一些预处理
例如： #include #define #if #else
1.#define写法： #define DEBUG false
======================c++信号处理===========================
C++ 信号处理库提供了 signal 函数，用来捕获突发事件。
signal(指令名,监听的方法)
======================c++多继承===========================
c++允许一个类拥有多个父类的做法
但会存在菱形继承这种情况，会造成程序的问题：
A->B,A->C,B->D,C->D (->代表继承) 用D获取A中的变量时，报二义性错误
解决方法：使用virtual：虚继承
======================c++虚函数,纯虚函数===========================
virtual void Test();//虚函数
virtual void Test1()=0;//纯虚函数
包含纯虚函数的类成为抽象类，无法被实例化

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员
必须实现这个函数。
======================c++指针和引用的区别===========================
1. 指针是一个实体，而引用仅是个别名；
2. 引用使用时无需解引用（*），指针需要解引用:
引用比指针使用起来形式上更漂亮，使用引用指向的内容时可以直接用引用变量名，
而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&取址。 
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
5. 引用不能为空，指针可以为空；
======================c++多态===========================
多态：相同方法名，实现不同
在c++中分为动态，静态多态
静态多态实际上就是函数重载，是编译器在编译期间完成的，所以称之为静态。
动态多态：子类通过继承重写父类中的虚函数实现的，在程序运行时根据基类的引用的
对象来引用父类还是子类的函数.
======================c++关于指针的理解===========================
1.(char)字符串本身就是一个地址，数据中的首地址，字符串它的本身就相当于字符数组名，
数组可以的操作，字符串也都可以。
char* ptr = "ABC"; ptr指针指向字符串的首字符，对ptr进行++操作可遍历字符串
通过向右移动指针来读取字符串
ptr++
cout<< ptr<< endl 结果：BC
ptr++
cout<< ptr<< endl 结果：C
2.int arr[]={1,2,3,4};
int* intPtr = arr;
cout << intPtr << endl; 结果：000000810396FCF0
cout << *intPtr << endl; 结果：1
intPtr++;
cout << *intPtr << endl; 结果：2
两者区别和相似：
同：指针开始赋值时，都是指向第一个元素，都可以通过对指针进行移动来遍历数组
异：获取值：char通过直接打印指针变量即可获取所指向的值后面的值；若打印*ptr，
则只会打印当前指向的那一个值；打印int指针变量，会返回地址,加上星号打印返回的
是当前指向的值
======================c++常用方法记录===========================
1.GetPrivateProfileInt
2._snprintf
3.GetPrivateProfileStringA
4.strchr
5.atoi
6._T
======================c++修饰符===========================



=================================================
1.构造函数带参时,调用实例化例如冒号用法第三种：	Message m1{222};

