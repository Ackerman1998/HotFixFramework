--[[
-- TimeManager
-- 定时管理器
--]]
local TimeManager=BaseClass("TimeManager",Singleton)
function _init(self)
    self._update_handle = nil
    self._coUpdate_handle = nil

    --存放定时器的池子
    self.timer_pool = {}

    self.__coupdate_toadd={}
end

local function DelayRecycle(self, timers)
    for k,v in ipairs(times) do
        if k:IsOver() then
            k:Stop()
            table.insert(timer_pool,k)
            timers[k]=nil
        end
    end
end

local function UpdateHandle(self)

end
--coUpdate
local function CoUpdateHandle(self)
    for timer,_ in ipairs(self.__coupdate_toadd) do
        timer:Update(false)
    end
    DelayRecycle(self,self.__coupdate_toadd)
end

--从这里启动
local function StartUp(self)
    --创建监听
    self._update_handle = UpdateBeat.CreateListener(UpdateHandle,TimeManager:GetInstance())
    self._coUpdate_handle = UpdateBeat.CreateListener(CoUpdateHandle,TimeManager:GetInstance())
    --添加监听
    UpdateBeat.AddListener(self._update_handle)
    UpdateBeat.AddListener(self._coUpdate_handle)
end
--获取定时器
local function GetTimer(self, delay, func, obj, one_shot, use_frame, unscaled)
    local timer = nil
    if #timer_pool>0 then
        timer = table.remove(timer_pool)
        timer:Init(delay, func, obj, one_shot, use_frame, unscaled)
    else
        timer = Timer.New(delay, func, obj, one_shot, use_frame, unscaled)
    end
    return timer
end

local function GetCoTimer(self, delay, func, obj, one_shot, use_frame, unscaled)
    local timer = GetTimer(self, delay, func, obj, one_shot, use_frame, unscaled)
    self.__coupdate_toadd[timer] = true
    return timer
end

function _delete(self)

end

TimeManager.StartUp=StartUp
TimeManager.GetCoTimer=GetCoTimer
return TimeManager

